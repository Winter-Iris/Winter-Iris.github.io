---
title: lab1
published: 2026-01-19
pinned: false
description: ucore-lab1实验
image: ""
tags:
  - 操作系统
category: 操作系统
draft: false
---



# 实模式&保护模式

## 实模式

- 这是 8086/8088 处理器的原始工作模式。<u>当一台 x86 电脑开机时，CPU 首先就运行在实模式下。</u>
- 在实模式下，任何一个程序（比如一个游戏或一个文本编辑器）都可以读写**任何**内存地址，包括操作系统内核所在的内存。
- 程序可以通过 **段地址：偏移地址** 的方式来访问 **1MB** 以内的任何内存位置，**物理地址 = 段地址 × 16 + 偏移地址**。
- 主要使用 16 位寄存器和 16 位指令。无法直接使用 32 位或 64 位的强大功能。

## 保护模式

- 实现了**内存管理与保护**
- CPU 和操作系统通过 **分段** 和 **分页** 机制，将程序的虚拟地址转换成实际的物理地址。因此将各个应用程序隔离开
- CPU 定义了 4 个特权级别，区分了用户态和内核态。
- 保护模式原生支持 32 位寄存器和寻址，可以访问多达 4GB（32位）甚至更多的物理内存。
# os启动过程

- 启动电源，进入实模式。
- 启动BIOS，加载第一条指令（CS+EIP指向：`CS*16+EIP`）。
- BIOS 将硬盘主引导记录（MBR）中的**引导程序**加载到内存并执行：BIOS进行硬件自检和初始化，完成工作后，选择一个启动设备，读取第一个扇区（主引导区）此时仍在**实模式**。
- 执行引导程序：将 CPU 从**实模式**切换到**保护模式**。（启用分段机制）。使能保护模式。(建立GDT，设置段寄存器的值满足映射关系，将CR0设置成1)
- 加载操作系统内核：读取磁盘中ELF执行文件格式的ucore操作系统内核到内存。显示字符串信息。
- 转移控制权给操作系统。

## bootloader进入保护模式的过程

- 开启A20。
- 建立GDT表，初始化。
- 设置CR0寄存器为1。

## 使用8042键盘控制器开启A20

- 8042`0x60,0x64`端口每一位的功能如下
```
0x60端口：
位映射：
位7: 键盘数据线
位6: 键盘时钟线  
位5: 输出缓冲区来源
位4: 输入缓冲区空标志
位3: 未使用
位2: 未使用
位1: A20 Gate (1开启!)
位0: 系统复位 (1不复位)

0x64端口：
位7：奇偶校验错误标志
位6：接收超时标志
位5：传输超时标志
位4：键盘禁止标志
位3：命令/数据标志
位2：系统标志
位1：输入缓冲区满标志/IBF(1为满，0为空)
位0：输出缓冲区满标志/OBF
```

- CPU写入输出端口的过程
	- 检测输入缓冲区是否为空：读取0x64端口的数据，检测其第一位数字(从低位到高位，且从0开始数位数)
	- 等待输入缓冲区不忙后，将0xd1写入端口0x64，即向控制器发送写入输出端口的命令。
	- 等待输入缓冲区不忙后，将0xdf写入端口0x60，即开启A20.

## 初始化GDT表流程

### **段描述符的结构**

- 全局段描述符表有若干个段描述符组成。
```c
static struct segdesc gdt[] = {
    SEG_NULL,
    [SEG_KTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_KERNEL),
    [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),
    [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),
    [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),
    [SEG_TSS]   = SEG_NULL,
};
```
- 如代码所示：GDT由空段描述符，内核代码段描述符，内核数据段描述符，用户代码段描述符，用户数据段描述符，和TSS描述符组成

- 段描述符结构如下：
```c
struct segdesc {
    unsigned sd_lim_15_0 : 16;  // 段界限的低16位      
    unsigned sd_base_15_0 : 16; // 段基址的低16位
    unsigned sd_base_23_16 : 8; // 段基址的16-23位
    unsigned sd_type : 4;       // 段类型
    unsigned sd_s : 1;          // 描述符类型
    unsigned sd_dpl : 2;        // 段描述符DPL特权级  
    unsigned sd_p : 1;          // 段存在标志
    unsigned sd_lim_19_16 : 4;  // 段界限高4位  
    unsigned sd_avl : 1;            
    unsigned sd_rsv1 : 1;            
    unsigned sd_db : 1;          // 默认操作数大小
    unsigned sd_g : 1;           // 粒度    
    unsigned sd_base_31_24 : 8;  //段基址24-31位
};
```
### **GDT初始化**

- 初始化GDT时，建立了三项段描述符,分别为**空描述符，供内核与bootloader使用的代码段描述符和数据段描述符**
```
gdt:
    SEG_NULLASM                                    
    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)          
    SEG_ASM(STA_W, 0x0, 0xffffffff)                
```
- 然后将gdt的**地址和大小保存在gdtdesc中**(三个描述符大小为`3*8=24`字节，因此界限为`23=0x17`)
```
gdtdesc:
    .word 0x17                                      # sizeof(gdt) - 1
    .long gdt                                       # address gdt
```
- 将gdtdesc**加载到gdtr寄存器中**
```
lgdt gdtdesc
```


### **Enable，进入保护模式**

- 将CR0的第0位（PE位）设置为1即可。



## bootloader加载ELF文件OS过程

### **bootloader读取磁盘扇区**：

- bootloader读取磁盘是LBA（逻辑块寻址）以及PIO（程序控制输入输出）方式实现的。
- **LBA磁盘寻址方式**：LBA 把硬盘当作一个**线性扇区数组**来处理： 每个扇区都有一个唯一的编号：LBA0, LBA1, LBA2, …。操作系统只需告诉硬盘要访问第几个扇区即可，**不用再管柱面、磁头、扇区的物理结构**。
- **PIO**（程序控制输入输出）是**CPU 直接控制数据传输**的一种方式。
- 读取过程：等待磁盘准备就绪，发送读取磁盘数据的指令，等待磁盘准备就绪，读取数据。
#### **磁盘控制器端口含义**：

| 寄存器名                              | 端口地址（主通道） | 说明              |
| --------------------------------- | --------- | --------------- |
| Data Register                     | 0x1F0     | 读写数据（16位）       |
| Error / Features                  | 0x1F1     | 错误码或特性          |
| Sector Count                      | 0x1F2     | 扇区数             |
| LBA Low                           | 0x1F3     | LBA地址低8位        |
| LBA Mid                           | 0x1F4     | LBA地址中8位        |
| LBA High                          | 0x1F5     | LBA地址高8位        |
| Drive / Head                      | 0x1F6     | 驱动器选择 + LBA高4位  |
| **Command / Status**              | **0x1F7** | 向其写入命令 / 从其读取状态 |
| Alternate Status / Device Control | 0x3F6     | 可选，读状态或复位设备     |
|                                   |           |                 |
#### **端口0x1F7各位含义**：

|位|名称|说明|
|---|---|---|
|Bit 7|**BSY (Busy)**|=1 表示磁盘正在执行操作（寻道、读写等），不能接受新命令。|
|Bit 6|**DRDY (Device Ready)**|=1 表示设备已准备好接受命令。|
|Bit 5|DF (Device Fault)|=1 表示设备出错或故障。|
|Bit 4|**DSC (Device Seek Complete)**|寻道完成。|
|Bit 3|DRQ (Data Request)|=1 表示数据寄存器准备好了可读/可写数据。|
|Bit 2|CORR (Corrected Data)|表示数据已纠错。|
|Bit 1|IDX (Index)|一圈旋转完成（旧设备用）。|
|Bit 0|**ERR (Error)**|=1 表示命令执行中出现错误。|
- 当最高两位为01时(`01000000=0x40`)，即准备好接受命令

### **加载ELF的OS文件**

- **ELF (Executable and Linkable Format)** 是 Linux/Unix 系统中用于可执行文件、目标文件（.o）、共享库（.so）、内核模块（.ko）等的标准二进制格式。

### **程序头表PHT**

- 在 ELF 文件中，**程序头表（Program Header Table）** 是操作系统加载器（loader）在运行 ELF 程序时最关心的部分。
- 程序头表由多个 **Program Header（程序头项）** 组成。**告诉“运行时应该把哪些部分加载进内存、加载到哪里”**。

###  **bootloader加载ELF的OS文件的过程**：
- 读取ELF文件头
- 检验是否为合法的ELF文件（检验`e_magic`），读取关键条目，获得程序头表的地址和大小（`e_phoff,e_phnum`）
- 遍历程序头表的每一项，得到每一段的地址`p_va`和大小`p_memsz`和偏移量`p_offset`，加载到内存中。(将文件中偏移`p_offset`后的`p_filesz`字节储存到内存中)
- 最后跳转至程序入口(`e_entry`)，执行程序。


- BootLoader先读取ELF文件头
```c
readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
```
- 然后检验ELF文件头的`e_magic`字段，判断是否合法
```c
if (ELFHDR->e_magic != ELF_MAGIC) {
	goto bad;
}
```
- 然后获取程序头表的地址和大小，得出程序头表的头指针和末尾指针
```c
struct proghdr *ph, *eph;
// load each program segment (ignores ph flags)
ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
eph = ph + ELFHDR->e_phnum;
```
- 然后遍历程序头表的每一项，将每一段读取到对应的内存区域
```c
for (; ph < eph; ph ++) {
	readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
}
```
- 最后跳转至程序入口，执行
```c
((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();
```


# 分段机制

- **不把内存看作一个从 0 开始的、巨大的线性数组，而是将其划分为逻辑上独立的区域，称为“段”。**

## 段寄存器

- **CS**：**代码段寄存器**，指向当前正在执行的程序**代码**所在的内存段。指令指针寄存器 (**IP/EIP/RIP**) 存储的是**偏移地址**。CPU 通过 `CS:IP` 的组合来获取下一条要执行的指令。
- **SS**：**栈段寄存器**，指向程序**栈**所在的内存段。栈指针寄存器 (**SP/ESP/RSP**) 存储的是栈顶的**偏移地址**。所有与栈相关的操作（`PUSH`, `POP`, `CALL`, `RET`）都自动使用 `SS:SP` 来寻址。
- **DS**：**数据段寄存器**，指向当前程序默认访问的**数据**所在的内存段。
- **ES**：**附加段寄存器**
- **FS**：**附加段寄存器**
- **GS**：**附加段寄存器**

## 保护模式下的分段

- **段描述符**：它详细描述了一个内存段的全部信息。
	- **段基址**：这个段在物理内存中的起始地址（32位或64位）。
	- **段界限**：这个段的大小/边界。
	- **访问权限**：这个段是否可读、可写、可执行。
	- **特权级**：这个段是运行在 Ring 0（内核）还是 Ring 3（用户程序）。
- **段描述符表**：它是在内存中的一个数组，由操作系统在启动保护模式时建立和维护。
	- **GDT**：全局描述符表，整个系统只有一个。
	- **LDT**：局部描述符表，每个任务可以有一个（现在较少使用）。
- **选择子**（段寄存器）：段寄存器里存放的是一个叫做**选择子**的索引。**选择子** 是一个 16 位的值，它不直接指向内存，而是作为一个**索引**，去一个全局的**段描述符表**里查找段的真实信息。


## 工作过程

当程序执行一条指令，CPU 会执行以下步骤：

- **查找描述符**：CPU 取出 `DS` 寄存器中的**选择子**，用它作为索引，从 **GDT** 中找到对应的**段描述符**。
- **权限检查**：CPU 检查当前程序的权限（CPL）是否足够访问这个段（例如，用户程序不能访问内核段）。同时检查操作类型（例如，不能向代码段写入数据）。
- **地址检查**：CPU 检查偏移地址 `0x1000` 是否超出了段描述符中定义的**段界限**。
- **计算线性地址**：如果所有检查都通过，CPU 将**段描述符中的段基址**加上**偏移地址** `0x1000`，得到一个**线性地址**。
- **分页机制介入**：这个线性地址随后会被送入**分页单元**，由分页机制将其转换为最终的**物理地址**（如果分页机制已启用）。如果未启用分页，那么这个线性地址就是物理地址。

# GCC内联汇编

- 语法
```c
asm [volatile] (
    "汇编指令模板"
    : "输出操作数"   // 可选
    : "输入操作数"   // 可选
    : "破坏列表"     // 可选
);
```

- **汇编指令模板**
	- 这是一个字符串，包含你的汇编指令。其中可以包含**操作数占位符**，如 `%0`, `%1`, `%2` 等，它们会按照后面操作数的顺序被替换。
- **输出操作数**
	- 指定汇编代码将修改哪些 C 变量。格式为：`"约束(变量名)"` **多个输出操作数用逗号分隔。**
	- **常用约束：**
	- ` =r`：将变量放入一个通用寄存器中，表示这个操作数是只写的。
	- ` +r`：将变量放入一个通用寄存器中，表示这个操作数既是输入又是输出。
	- ` =m`：将变量放入内存中（直接操作内存地址）。
- **输入操作数**
	- 指定汇编代码会读取哪些 C 变量。格式与输出操作数类似。
	- `r`：将表达式（变量）的值放入一个通用寄存器。    
	- `m`：直接使用表达式（变量）的内存地址。
	- `i`：一个立即整数。 
- **破坏列表**（Clobber List）
	- 告诉编译器，除了输出操作数之外，汇编代码还**隐式地**修改了哪些资源。这可以防止编译器的优化器在这些地方做出错误的假设。
	- **常用破坏项：**
		- `"cc"`：表示汇编代码修改了**条件码寄存器**（例如 x86 的 FLAGS 寄存器）。
		- `"memory"`：表示汇编代码对内存进行了读写操作，而不仅仅是列出的输入输出操作数指向的内存。这会强制编译器在汇编指令之前，将所有寄存器中缓存的 memory 值写回，并在之后重新加载。这是一种很强的内存屏障。
		- 寄存器名：例如 `"eax"`, `"r1"`，表示你手动修改了这个寄存器。**通常更推荐让编译器通过操作数来为你分配寄存器。**
-  `volatile` 关键字
	- `volatile` 是可选的。它告诉编译器： “不要优化这段内联汇编，原样保留它。”

# 中断处理

- **来源**：
	- **外中断**： 外部硬件产生的中断
	- **异常**：由 CPU 内部执行指令时检测到的错误条件产生
	- **软中断**：系统调用通过软件中断实现

- **处理过程**：
	- 产生中断，根据中断号查找IDT表，找到对应的中断处理程序
	- 从找到的中断门找到对应的段选择子
	- 根据段选择子在GDT找到中断处理程序的基地址加上偏移量即可找到。

## 中断描述符表（IDT）

- 作用：建立中断号（或异常号）与对应中断处理程序（ISR）之间的映射关系。在CPU发生中断时，查询中断号对应的处理入口，直接跳转处理。

## IDTR结构

- IDTR共48位，6个字节：

| `[0:15]`  | `[16:47]` |
| --------- | --------- |
| IDT limit | IDT 基址    |

## 中断描述符

 中断描述符一般结构：
 
| 字段                        | 含义                       |
| ------------------------- | ------------------------ |
| **偏移地址 (Offset)**         | 中断处理函数的地址（低16位 + 高16位）   |
| **段选择子 (Selector)**       | 指向内核代码段（一般是 `CS`）        |
| **属性字段 (Type & DPL & P)** | 描述该门的类型（中断门/陷阱门）、权限、是否有效 |
| **保留字段**                  | 通常为 0                    |
- 32位处理器下，每一项占8个字节。结构如下：


| bit | `[0:15]`       | `[16:31]`          | `[32:39]`  | `[40:43]` | `[44]` | `[45:46]` | `[47]` | `[48:63]`       |
| --- | -------------- | ------------------ | ---------- | --------- | ------ | --------- | ------ | --------------- |
| 含义  | `offset[0:15]` | `segment selector` | `args+rsv` | `type`    | `s`    | `dpl`     | `p`    | `offset[16:31]` |

- 中断描述符如下：
```c
struct gatedesc {
    unsigned gd_off_15_0 : 16;    // 偏移量0-15位
    unsigned gd_ss : 16;          // 段选择子，指定中断处理程序所在的代码段
    unsigned gd_args : 5;         // 
    unsigned gd_rsv1 : 3;         //
    unsigned gd_type : 4;         // 门类型
    unsigned gd_s : 1;            //  
    unsigned gd_dpl : 2;          // 描述符特权级
    unsigned gd_p : 1;            // 段存在标志
    unsigned gd_off_31_16 : 16;   // 偏移量16-31位  
};
```
## IDT初始化

- 分配一个 IDT 数组
- 为每个中断号设置处理程序
- 加载 IDT到IDTR寄存器中（IDT的起始地址和大小）

```c
void
idt_init(void) {
	// 分配一个 IDT 数组
    extern uintptr_t __vectors[];
    int i;
	// 为每个中断号设置处理程序,
    for (i = 0; i < sizeof(idt) / sizeof(struct gatedesc); i ++) {
        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);
    }
    // 加载 IDT到IDTR寄存器中（IDT的起始地址和大小）
    lidt(&idt_pd);
}
```

```c
// 设置中断门的宏（要设置的中断门，是否是陷阱门，段选择子，偏移量，特权级）
#define SETGATE(gate, istrap, sel, off, dpl) {           \
	(gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;      \
	(gate).gd_ss = (sel);                               \
	(gate).gd_args = 0;                                 \
	(gate).gd_rsv1 = 0;                                 \
	(gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \
	(gate).gd_s = 0;                                    \
	(gate).gd_dpl = (dpl);                              \
	(gate).gd_p = 1;                                    \
	(gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
}
```

```c
// 内核代码段选择子
#define GD_KTEXT    ((SEG_KTEXT) << 3)      // kernel text
```