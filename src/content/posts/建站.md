---
title: 建站记录~
published: 2026-01-19
pinned: true
description: 一个建站记录喵
image: ""
tags:
  - Mizuki
  - Guides
category: Guides
draft: false
---

# 拉取仓库


- 访问 Mizuki 的 GitHub 仓库（通常是 `matsuzaka-yuki/Mizuki`）。
- 点击右上角的 **Fork** 按钮。
- Repository name (仓库名)填 `你的用户名.github.io`。这样你的博客网址就是 `https://你的用户名.github.io`（根域名）。
- 点击 **Create fork**。
- **克隆到本地：**
    - 在你的电脑上新建一个文件夹。
    - 打开终端（CMD 或 PowerShell），输入：

```bash
git clone https://github.com/你的用户名/你的仓库名.git
```

# 安装依赖

```bash
npm install -g pnpm
```

```bash
pnpm install
```

# 编辑配置

- 编辑 `src/config.ts` 自定义博客设置，设置成你自己的url
```ts
export const siteConfig: SiteConfig = {
	title: "Mizuki",
	subtitle: "One demo website",
	siteURL: "https://用户名.github.io/", // 请替换为你的站点URL，以斜杠结尾
	siteStartDate: "2025-01-18", // 站点开始运行日期，用于站点统计组件计算运行天数
	...
}

```
- 其他配置看注释即可，这里省略。
# 添加自动部署脚本

## 设置Github Action

1. 打开 GitHub 仓库页面。
2. 点击顶部的 **Settings (设置)**。
3. 在左侧栏点击 **Pages**。
4. 找到 **Build and deployment (构建和部署)** 区域。
5. 查看 **Source (来源)** 这一栏：
    - **请修改为：** **GitHub Actions**。

## 添加脚本

- 在项目目录`.github/workflows/`目录下创建文件`deploy.yml`
```yml
# deploy.yml
name: Deploy to Github Pages
on:
    # 每次推送到 master 分支时自动触发
    push:
        branches: [ master ]
    # 允许在 Github Action 手动触发
    workflow_dispatch:

# 权限设置
permissions:
    contents: read
    pages: write
    id-token: write

jobs:
    build:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout your repository
              uses: actions/checkout@v4
            # 使用 Astro 官方动作，它会自动识别 pnpm-lock.yaml 并使用 pnpm 安装依赖
            - name: Install, build, and upload your site
              uses: withastro/action@v2
    deploy:
        needs: build
        runs-on: ubuntu-latest
        environment:
          name: github-pages
          url: ${{ steps.deployment.outputs.page_url }}
        steps:
            - name: Deploy to GitHub Pages
              id: deployment
              uses: actions/deploy-pages@v4
```
- 然后每次push的时候就会自动部署了！

# 配置字体

- 将字体文件放入`/public/assets/font/`目录下
- 在全局css中注册字体`/src/styles/main.css`
```css
@font-face {
  font-family: 'MYFONTS'; /* 给字体起个名字，随便起，后面配置要用 */
  src: url('/assets/font/myfonts.ttf') format('truetype'); /* 对应刚才放文件的路径 */
  font-display: swap;
  font-weight: normal;
  font-style: normal;
}
```
- 修改`config`，按需修改即可
```ts
export const siteConfig: SiteConfig = {
	...
	// 字体配置
	font: {
		// 注意：自定义字体需要在 src/styles/main.css 中引入字体文件
		// 注意：字体子集优化功能目前仅支持 TTF 格式字体,开启后需要在生产环境才能看到效果,在Dev环境下显示的是浏览器默认字体!
		asciiFont: {
			// 英文字体 - 优先级最高
			// 指定为英文字体则无论字体包含多大范围，都只会保留 ASCII 字符子集
			fontFamily: "ZenMaruGothic-Medium",
			fontWeight: "400",
			localFonts: ["ZenMaruGothic-Medium.ttf"],
			enableCompress: true, // 启用字体子集优化，减少字体文件大小
		},
		cjkFont: {
			// 中日韩字体 - 作为回退字体
			fontFamily: "MYFONTS",
			fontWeight: "500",
			localFonts: ["myfonts.ttf"],
			enableCompress: true, // 启用字体子集优化，减少字体文件大小
		},
	},
	...
}
```

# 公告栏支持换行符

在`\src\components\widget\Announcement.astro` 路径下将
```html
<!-- 公告栏内容 -->
<div class="text-neutral-600 dark:text-neutral-300 leading-relaxed mb-3 ">
	{config.content}
</div>
```
修改为：
```html
<!-- 公告栏内容 -->
<div class="text-neutral-600 dark:text-neutral-300 leading-relaxed mb-3 whitespace-pre-line">
	{config.content}
</div>
```

# 配置一言副标题

在`\src\utils\`路径下添加 `typewriter.ts`，将原组件中的类提取出来

```ts
# typewriter.ts
export class TypewriterEffect {
    private element: HTMLElement;
    private texts: string[];
    private currentTextIndex: number = 0;
    private speed: number;
    private deleteSpeed: number;
    private pauseTime: number;
    private currentIndex: number = 0;
    private isDeleting: boolean = false;
    private timeoutId: number | null = null;

    private textFetcher?: () => Promise<string>;

    // 修改构造函数：支持传入配置对象，方便手动调用
    constructor(element: HTMLElement, options?: {
            text?: string | string[], 
            speed?: number, 
            deleteSpeed?: number, 
            pauseTime?: number,
            textFetcher?: () => Promise<string>
        }) {
        this.element = element;
        this.textFetcher = options?.textFetcher;
        // 优先使用传入的配置，如果没有则读取 DOM 上的 data 属性
        const textData = options?.text || element.dataset.text || '';
        
        if (Array.isArray(textData)) {
            this.texts = textData;
        } else {
            try {
                const parsed = JSON.parse(textData as string);
                this.texts = Array.isArray(parsed) ? parsed : [textData as string];
            } catch {
                this.texts = [textData as string];
            }
        }

        this.speed = options?.speed ?? parseInt(element.dataset.speed || '100');
        this.deleteSpeed = options?.deleteSpeed ?? parseInt(element.dataset.deleteSpeed || '50');
        this.pauseTime = options?.pauseTime ?? parseInt(element.dataset.pauseTime || '2000');

        if ( (this.texts.length > 1 || this.textFetcher) && !this.isTypewriterEnabled()) {
            this.showRandomText();
        } else {
            this.start();
        }
    }

    private isTypewriterEnabled(): boolean {
        return this.element.dataset.speed !== undefined ||
               this.element.dataset.deleteSpeed !== undefined || 
               this.element.dataset.pauseTime !== undefined;
    }

    private showRandomText() {
        if (this.texts.length === 0) return;
        const randomIndex = Math.floor(Math.random() * this.texts.length);
        this.element.textContent = this.texts[randomIndex];
    }

    private start() {
        if (this.texts.length === 0) return;
        this.element.textContent = ''; // 确保开始时为空
        this.type();
    }

    private getCurrentText(): string {
        return this.texts[this.currentTextIndex] || '';
    }

    private type() {
        const currentText = this.getCurrentText();
        if (this.isDeleting) {
            if (this.currentIndex > 0) {
                this.currentIndex--;
                this.element.textContent = currentText.substring(0, this.currentIndex);
                this.timeoutId = window.setTimeout(() => this.type(), this.deleteSpeed);
            } else {
                this.isDeleting = false;
                // 如果有获取器，去获取新的一言
                if (this.textFetcher) {
                    this.textFetcher().then(newText => {
                        this.texts = [newText]; // 更新文本库
                        this.currentTextIndex = 0;
                        this.type(); // 重新开始打字
                    });
                    return; // 暂停循环，等待网络请求
                }
                // 否则执行原有的静态循环逻辑
                this.currentTextIndex = (this.currentTextIndex + 1) % this.texts.length;
                this.timeoutId = window.setTimeout(() => this.type(), this.speed);
            }
        } else {
            if (this.currentIndex < currentText.length) {
                this.currentIndex++;
                this.element.textContent = currentText.substring(0, this.currentIndex);
                this.timeoutId = window.setTimeout(() => this.type(), this.speed);
            } else {
                if (this.texts.length > 1 || this.textFetcher) {
                    this.isDeleting = true;
                    this.timeoutId = window.setTimeout(() => this.type(), this.pauseTime);
                }
            }
        }
    }

    public destroy() {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
        }
    }
}
```

在`src\components\`下添加`TypewriterText.astro`
```astro
---
export interface Props {
	text: string | string[];
	speed?: number;
	deleteSpeed?: number;
	pauseTime?: number;
	class?: string;
}

const {
	text,
	speed = 100,
	deleteSpeed = 50,
	pauseTime = 2000,
	class: className = "",
} = Astro.props;
const textData = Array.isArray(text) ? JSON.stringify(text) : text;
---

<span class={`typewriter ${className}`} data-text={textData} data-speed={speed} data-delete-speed={deleteSpeed} data-pause-time={pauseTime}></span>

<script>
import { TypewriterEffect } from "../utils/typewriter";

// 初始化逻辑保持不变
document.addEventListener('astro:page-load', () => {
    const typewriterElements = document.querySelectorAll('.typewriter');
    typewriterElements.forEach((element) => {
        new TypewriterEffect(element as HTMLElement);
    });
});
</script>

<style>
/* 样式保持不变 */
.typewriter {
    position: relative;
    min-height: 1.5em;
    display: inline-block;
    vertical-align: baseline;
}
.typewriter:empty::before {
    content: '\00A0';
    visibility: hidden;
}
</style>

<script>

    import { TypewriterEffect } from "../utils/typewriter";

    function initTypewriters() {
        const typewriterElements = document.querySelectorAll('.typewriter');
        typewriterElements.forEach((element) => {
            // 检查是否已经初始化过（避免重复打字），如果没有则初始化
            if (!(element as any)._typewriter) {
                (element as any)._typewriter = new TypewriterEffect(element as HTMLElement);
            }
        });
    }

    // 初始加载时运行
    document.addEventListener('DOMContentLoaded', initTypewriters);
    
    // 页面切换后运行 (这是关键！)
    document.addEventListener('swup:contentReplaced', initTypewriters);
</script>
```

在`src\layouts\MainGridLayout.astro` 中找到`banner-subtitle` 修改为

```astro
{siteConfig.banner.homeText?.subtitle && (
    <h2 class="banner-subtitle text-xl lg:text-3xl text-white/90 drop-shadow-md">
	    {siteConfig.banner.homeText.hitokoto ? (
		/*  一言打字机  */
		<>
			   <span 
			id="hitokoto-text" 
			class="typewriter inline-block min-h-[1.2em]"
			data-speed={siteConfig.banner.homeText.typewriter?.speed ?? 100}
			data-delete-speed={siteConfig.banner.homeText.typewriter?.deleteSpeed ?? 50}
			data-pause-time={siteConfig.banner.homeText.typewriter?.pauseTime ?? 2000}
>
					Loading ...
				</span>
				<script>          
					import { TypewriterEffect } from "../utils/typewriter";
					function initHitokoto() {
						const container = document.getElementById('hitokoto-text');
						if (!container) return;
						// 从 data 属性读取配置
						const speed = parseInt(container.dataset.speed || '100');
						const deleteSpeed = parseInt(container.dataset.deleteSpeed || '50');
						const pauseTime = parseInt(container.dataset.pauseTime || '2000');

						// 定义获取一言的函数（返回 Promise）
						const fetcher = () => {
							return fetch('https://v1.hitokoto.cn')
								.then(response => response.json())
								.then(data => `${data.hitokoto} —— ${data.from}`)
								.catch(err => {
									console.error("一言获取失败:", err);
									return "获取失败了...";
								});
						};

						// 启动
						fetcher().then(initialText => {
							new TypewriterEffect(container, {
								text: initialText,
								textFetcher: fetcher,
								speed: speed,
								deleteSpeed: deleteSpeed,
								pauseTime: pauseTime
							});
						});
					}
					
					initHitokoto();
					document.addEventListener('swup:contentReplaced', initHitokoto);
				</script>
			</>
		) : (
			/* 静态配置打字机 */
			<span class="inline-block min-h-[1.2em]">
				{siteConfig.banner.homeText.typewriter?.enable ? (
					<TypewriterText 
						text={siteConfig.banner.homeText.subtitle}
						speed={siteConfig.banner.homeText.typewriter.speed}
						deleteSpeed={siteConfig.banner.homeText.typewriter.deleteSpeed}
						pauseTime={siteConfig.banner.homeText.typewriter.pauseTime}
					/>
				) : (
					Array.isArray(siteConfig.banner.homeText.subtitle) 
						? siteConfig.banner.homeText.subtitle[0] 
						: siteConfig.banner.homeText.subtitle
				)}
			</span>
		)}
	</h2>
)}
```

修改`\src\types\config.ts` 添加配置项 `hitokoto?: boolean;`
```ts
banner: {
	src:
		| string
		| string[]
		| {
				desktop?: string | string[];
				mobile?: string | string[];
		  }; // 支持单个图片、图片数组或分别设置桌面端和移动端图片
	position?: "top" | "center" | "bottom";
	carousel?: {
		enable: boolean; // 是否启用轮播
		interval: number; // 轮播间隔时间（秒）
	};
	waves?: {
		enable: boolean; // 是否启用水波纹效果
		performanceMode?: boolean; // 性能模式：减少动画复杂度
		mobileDisable?: boolean; // 移动端禁用
	};
	imageApi?: {
		enable: boolean; // 是否启用图片API
		url: string; // API地址，返回每行一个图片链接的文本
	};
	homeText?: {
		enable: boolean; // 是否在首页显示自定义文字
		title?: string; // 主标题
		subtitle?: string | string[]; // 副标题，支持单个字符串或字符串数组
		typewriter?: {
			enable: boolean; // 是否启用打字机效果
			speed: number; // 打字速度（毫秒）
			deleteSpeed: number; // 删除速度（毫秒）
			pauseTime: number; // 完整显示后的暂停时间（毫秒）
		};
		hitokoto?: boolean; // ADD:是否启用一言API替代副标题
	};
	credit: {
		enable: boolean;
		text: string;
		url?: string;
	};
	navbar?: {
		transparentMode?: "semi" | "full" | "semifull"; // 导航栏透明模式
	};
};
```
启用功能,在`src\config.ts`中
```ts
homeText: {
	enable: true, // 在主页显示自定义文本
	title: "沐雪凌鸢-WinterIris", // 主页横幅主标题

	subtitle: [
		"特別なことはないけど、君がいると十分です",
		"今でもあなたは私の光",
		"君ってさ、知らないうちに私の毎日になってたよ",
		"君と話すと、なんか毎日がちょっと楽しくなるんだ",
		"今日はなんでもない日。でも、ちょっとだけいい日",
	],
	hitokoto: true, // ADD:启用一言API
	typewriter: {
		enable: true, // 启用副标题打字机效果
		speed: 100, // 打字速度（毫秒）
		deleteSpeed: 50, // 删除速度（毫秒）
		pauseTime: 2000, // 完全显示后的暂停时间（毫秒）
	},
},
```

# 配置追番进度

在`src\config.ts`中
```ts
bangumi: {
	userId: "yourID", // 在此处设置你的Bangumi用户ID，可以设置为 "sai" 测试
	fetchOnDev: true, // 是否在开发环境下获取 Bangumi 数据（默认 false），获取前先执行 pnpm build 构建 json 文件
},

anime: {
	mode: "bangumi", // 番剧页面模式："bangumi" 使用Bangumi API，"local" 使用本地配置
},
```
运行(本地测试)
```bash
pnpm build
pnpm dev
```

# 开启滚动条

在`src/layouts/Layout.astro`中，找到
```astro
<html
    lang={siteLang}
    class="bg-[var(--page-bg)] text-[14px] md:text-[16px]"
    data-overlayscrollbars-initialize  >
```
修改为
```astro
<html
    lang={siteLang}
    class="bg-[var(--page-bg)] text-[14px] md:text-[16px]"
>
```
找到
```astro
<body
    class="min-h-screen"
    class:list={[
        { "lg:is-home": isHomePage, "enable-banner": enableBanner },
    ]}
    style={bodyFontFamily ? `font-family: ${bodyFontFamily};` : ""}
    data-overlayscrollbars-initialize >
```
修改为
```astro
<body
    class="min-h-screen"
    class:list={[
        { "lg:is-home": isHomePage, "enable-banner": enableBanner },
    ]}
    style={bodyFontFamily ? `font-family: ${bodyFontFamily};` : ""}
>
```
找到下面这个样式快
```css
<style
	is:global
	define:vars={{
		bannerOffset,
		"banner-height-home": `${BANNER_HEIGHT_HOME}vh`,
		"banner-height": `${BANNER_HEIGHT}vh`,
	}}
>
```
中的
```css
@layer components {
	...
}
```
修改为：
```css
@layer components {
	.enable-banner.is-home #banner-wrapper {
		@apply h-[var(--banner-height-home)] translate-y-[var(--banner-height-extend)];
	}
	.enable-banner #banner-wrapper {
		@apply h-[var(--banner-height-home)];
	}
	.enable-banner.is-home #banner {
		@apply h-[var(--banner-height-home)] translate-y-0;
	}
	.enable-banner #banner {
		@apply h-[var(--banner-height-home)] translate-y-[var(--bannerOffset)];
	}
	.enable-banner.is-home #main-grid {
		@apply translate-y-[var(--banner-height-extend)];
	}
	.enable-banner #top-row {
		@apply h-[calc(var(--banner-height-home)_-_4.5rem)] transition-all duration-300;
	}
	.enable-banner.is-home #sidebar-sticky {
		@apply top-[calc(1rem_-_var(--banner-height-extend))];
	}
	.navbar-hidden {
		@apply opacity-0 -translate-y-16;
	}

	/* Water waves animation */
	.waves > .parallax use {
		animation: wave 25s cubic-bezier(0.5, 0.5, 0.45, 0.5) infinite;
	}
	@keyframes wave {
		0% {
			transform: translate3d(-90px, 0, 0);
		}
		100% {
			transform: translate3d(85px, 0, 0);
		}
	}


	:root {
		/* 轨道背景设为透明 */
		--scrollbar-bg: transparent;
		
		/* 浅色模式下的滑块颜色 (稍微加深一点以便在白底上看清) */
		--scrollbar-thumb: #b0b0b0;    
		--scrollbar-thumb-hover: #909090;
	}

	/* 深色模式适配 */
	:root[class~="dark"] {
		--scrollbar-bg: transparent;
		
		/* 深色模式下的滑块颜色 */
		--scrollbar-thumb: #555555;
		--scrollbar-thumb-hover: #777777;
	}
	
	/* 媒体查询备用 */
	@media (prefers-color-scheme: dark) {
		:root:not([data-theme="light"]) {
			--scrollbar-bg: transparent;
			--scrollbar-thumb: #555555;
			--scrollbar-thumb-hover: #777777;
		}
	}

	/* Webkit (Chrome/Edge/Safari) */
	::-webkit-scrollbar {
		width: 10px;  /* 稍微改窄一点，显得更精致 */
		height: 10px;
	}
	
	/* 轨道：完全透明 */
	::-webkit-scrollbar-track {
		background: transparent; 
	}

	/* 滑块：利用 border 和 background-clip 实现悬浮效果 */
	::-webkit-scrollbar-thumb {
		background-color: var(--scrollbar-thumb);
		border-radius: 10px; /* 两端完全圆角 */
		
		/* 关键技巧：设置透明边框，让滑块看起来像是"悬浮"在中间，有一点间隙 */
		border: 2px solid transparent; 
		background-clip: content-box; 
	}

	/* 鼠标悬停在滑块上 */
	::-webkit-scrollbar-thumb:hover {
		background-color: var(--scrollbar-thumb-hover);
	}

	/* Firefox 浏览器样式 */
	html {
		overflow-y: auto; 
		scroll-behavior: smooth;
		
		/* Firefox 的写法：参数1是滑块，参数2是轨道(这里设为透明) */
		scrollbar-color: var(--scrollbar-thumb) transparent;
		scrollbar-width: thin;
	}
}
```

# Unami统计

- 在 https://cloud.umami.is/ 创建账号
-  **+ Add Website** 按钮。
	- **Name**: 随便填（例如“我的博客”）。
	- **Domain**: 填您的博客域名（例如 `yourname.github.io` 或 `blog.com`）。
- 添加完成后，在列表中找到您的网站，点击右侧的 **Edit (编辑)** 按钮，复制`Tracking code`
- 即长得像这样的代码
`<script defer src="https://cloud.umami.is/script.js" data-website-id="xxxxxxx"></script>`

- 在`/src/config.ts`里面替换`scripts`，并打开`enable`
```ts
export const umamiConfig = {
	enabled: true, // 是否显示Umami统计
	apiKey: import.meta.env.UMAMI_API_KEY || "api_xxxxxxxx", // API密钥优先从环境变量读取，否则使用配置文件中的值
	baseUrl: "https://api.umami.is", // Umami Cloud API地址
	scripts: `替换此处`.trim(), // 上面填你要插入的Script,不用再去Layout中插入
} as const;
```
- 获取API密钥，不要直接在文件里引用
- 在项目根目录下创建一个`.env`文件，放入你的API密钥即可。
```env
UMAMI_API_KEY=api_xxxxxx
```
- 配置github工作流的API密钥，确保其正确部署
	1. 打开博客的 **GitHub 仓库页面**。
	2. 点击上方的 **Settings (设置)**。
	3. 在左侧菜单栏找到 **Secrets and variables** -> 点击 **Actions**。
	4. 点击绿色的 **New repository secret** 按钮。
	    - **Name**: 填 `UMAMI_API_KEY` (必须和代码里的一样)。
	    - **Secret**: 填您的API密钥。
	5. 点击 **Add secret**。
- 配置工作流文件获取密钥，修改`.github/workflows/deploy.yml`，替换`jobs`为以下内容
```yml
jobs:
    build:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout your repository
              uses: actions/checkout@v4
            # 使用 Astro 官方动作，它会自动识别 pnpm-lock.yaml 并使用 pnpm 安装依赖
            - name: Install, build, and upload your site
              uses: withastro/action@v2
              env:
                UMAMI_API_KEY: ${{ secrets.UMAMI_API_KEY }}
    deploy:
        needs: build
        runs-on: ubuntu-latest
        environment:
          name: github-pages
          url: ${{ steps.deployment.outputs.page_url }}
        steps:
            - name: Deploy to GitHub Pages
              id: deployment
              uses: actions/deploy-pages@v4
```


# 文章属性

| **属性 (Attribute)** | **描述 (Description)**                                                                                                    |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------- |
| **`title`**        | 文章的标题。                                                                                                                  |
| **`published`**    | 文章的发布日期。                                                                                                                |
| **`pinned`**       | 是否将此文章置顶（固定在文章列表顶部）。                                                                                                    |
| **`priority`**     | 置顶文章的优先级。数值越小，优先级越高（如 0, 1, 2...）。                                                                                      |
| **`description`**  | 文章的简短描述。会显示在首页或文章列表中。                                                                                                   |
| **`image`**        | 文章的封面图片路径。<br>1. 以 `http://` 或 `https://` 开头：使用网络图片<br>2. 以 `/` 开头：使用 `public` 目录下的图片  <br>3. 无前缀：使用相对于该 Markdown 文件的图片 |
| **`tags`**         | 文章的标签（数组格式）。                                                                                                            |
| **`category`**     | 文章的分类。                                                                                                                  |
| **`licenseName`**  | 该文章内容的授权协议名称（例如 CC BY-NC-SA 4.0）。                                                                                       |
| **`author`**       | 文章的作者名称。                                                                                                                |
| **`sourceLink`**   | 文章内容的原文链接或参考链接（通常用于转载）。                                                                                                 |
| **`draft`**        | 是否为草稿。如果设为 `true`，则不会在网站上显示。                                                                                            |
